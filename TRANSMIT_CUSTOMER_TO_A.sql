CREATE OR REPLACE PROCEDURE TRANSMIT_CUSTOMER_TO_A
IS

  STATUS_FOR_TRANSMIT CONSTANT CHAR(100) := 'FOR_TRANSMIT';
  STATUS_INITIALIZE CONSTANT   CHAR(100) := 'INITIALIZE';
  STATUS_NOT_FOUND CONSTANT    CHAR(100) := 'NOT_FOUND';
  STATUS_NOT_REQUIRE CONSTANT  CHAR(100) := 'CUSTOMER_NOT_REQUIRE';
  STATUS_PREPARE CONSTANT      CHAR(100) := 'PREPARE_FOR_TRANSMIT';
  STATUS_SUCCESS CONSTANT      CHAR(100) := 'SUCCESS';

  C_RESULT                     CHAR(100);

  N_RUN_NUMBER                 NUMBER := 0;

  S_E_SQLCODE                  VARCHAR(4000) := '';
  S_E_SQLERRM                  VARCHAR(4000) := '';
  S_ERROR_MESSAGE              VARCHAR(4000) := '';
  S_CALL_STACK                 VARCHAR(32767) := '';
  S_ERROR_BACKTRACE            VARCHAR(32767) := '';
  S_ERROR_STACK                VARCHAR(32767) := '';

  S_ADDITIONAL_INFORMATION     CLOB := '';

  PROCEDURE ADD_LOG(
    N_RUN_NUMBER IN          NUMBER,
    S_MESSAGE    IN          VARCHAR DEFAULT NULL,
    S_ADDITIONAL_INFORMATION CLOB DEFAULT NULL

  ) IS
    WORKING_MESSAGE_SIZE CONSTANT INTEGER := 4000;
    S_WORKING_MESSAGE             VARCHAR(4000);
    BEGIN
      S_WORKING_MESSAGE := SUBSTR(S_MESSAGE, 1, WORKING_MESSAGE_SIZE);

      INSERT INTO SOME.TRANSMITING_LOG
      (RUN_NUMBER, MESSAGE, ADDITIONAL_INFORMATION)
      VALUES (N_RUN_NUMBER, S_WORKING_MESSAGE, S_ADDITIONAL_INFORMATION);

      EXCEPTION
      WHEN OTHERS THEN
      NULL;
    END;

  PROCEDURE INITIALIZE IS
    BEGIN
      DELETE FROM RTL_A.TRANSMITING_ADDRESS;
      DELETE FROM RTL_A.TRANSMITING_CERTIFICATE;
      DELETE FROM RTL_A.TRANSMITING_CONTACT;
      DELETE FROM RTL_A.TRANSMITING_CUSTOMER;

      INSERT INTO RTL_B.TRANSMITING_CUSTOMER
      (SYNCHRONIZE_ROWID)
        SELECT ROWID
        FROM
          RTL_B.CUSTOMER_SYNCHRONIZE S
        WHERE
          S.SYNCHRONIZE_STATUS = STATUS_FOR_TRANSMIT;
    END;

  PROCEDURE INITIALIZE_SYNCHRONIZE(N_RUN IN NUMBER) IS

    CURSOR GET_FOR_INITIALIZE IS
      SELECT
        S.ROWID AS SYNCHRONIZE_ROWID,
        S.SYNCHRONIZE_STATUS
      FROM
        RTL_B.TRANSMITING_CUSTOMER T
        JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
          ON T.SYNCHRONIZE_ROWID = S.ROWID
      WHERE
        S.SYNCHRONIZE_STATUS = STATUS_FOR_TRANSMIT
      FOR UPDATE SKIP LOCKED
    ;

    TYPE T_FOR_INITIALIZE IS TABLE OF GET_FOR_INITIALIZE%ROWTYPE INDEX BY PLS_INTEGER;
    A_CUSTOMER_FOR_INITIALIZE T_FOR_INITIALIZE;

    N_START                   NUMBER := 0;
    N_FINISH                  NUMBER := 0;

    S_ERROR                   VARCHAR2(4000) := '';
    S_SQLCODE                 VARCHAR2(4000) := '';
    S_SQLERRM                 VARCHAR2(4000) := '';
    N_ERROR_COUNT             NUMBER := 0;

    B_IS_EXISTS               BOOLEAN := FALSE;

    BEGIN
      OPEN GET_FOR_INITIALIZE;
      FETCH GET_FOR_INITIALIZE BULK COLLECT INTO A_CUSTOMER_FOR_INITIALIZE;
      CLOSE GET_FOR_INITIALIZE;

      N_START := A_CUSTOMER_FOR_INITIALIZE.FIRST;
      N_FINISH := A_CUSTOMER_FOR_INITIALIZE.LAST;

      B_IS_EXISTS := N_FINISH > 0 AND N_START > 0;

      IF (B_IS_EXISTS)
      THEN
        BEGIN
          FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
          UPDATE RTL_B.CUSTOMER_SYNCHRONIZE
          SET SYNCHRONIZE_STATUS = STATUS_INITIALIZE
          WHERE
            RTL_B.CUSTOMER_SYNCHRONIZE.ROWID = A_CUSTOMER_FOR_INITIALIZE(indx).SYNCHRONIZE_ROWID;

          EXCEPTION
          WHEN OTHERS THEN

          N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
          FOR i IN 1 .. N_ERROR_COUNT
          LOOP
            S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
            S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

            S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

            ADD_LOG(N_RUN, S_ERROR);

          END LOOP;
        END;
      END IF;

      COMMIT;
    END;

  PROCEDURE EXCLUDE_NOT_FOUND(N_RUN IN NUMBER) IS

    CURSOR GET_NOT_FOUND IS
      SELECT S.ROWID AS SYNCHRONIZE_ROWID
      FROM
        RTL_B.TRANSMITING_CUSTOMER T
        JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
          ON T.SYNCHRONIZE_ROWID = S.ROWID
        LEFT JOIN RTL_B.CUSTOMER C
          ON S.CUSTOMER_CODE = C.CODE
      WHERE
        C.CODE IS NULL
        AND S.SYNCHRONIZE_STATUS = STATUS_INITIALIZE
    ;

    TYPE T_NOT_FOUND IS TABLE OF GET_NOT_FOUND%ROWTYPE INDEX BY PLS_INTEGER;
    A_CUSTOMER_NOT_FOUND T_NOT_FOUND;

    N_START              NUMBER := 0;
    N_FINISH             NUMBER := 0;

    S_ERROR              VARCHAR2(4000) := '';
    S_SQLCODE            VARCHAR2(4000) := '';
    S_SQLERRM            VARCHAR2(4000) := '';
    N_ERROR_COUNT        NUMBER := 0;

    B_IS_EXISTS          BOOLEAN := FALSE;

    BEGIN
      OPEN GET_NOT_FOUND;
      FETCH GET_NOT_FOUND BULK COLLECT INTO A_CUSTOMER_NOT_FOUND;
      CLOSE GET_NOT_FOUND;

      N_START := A_CUSTOMER_NOT_FOUND.FIRST;
      N_FINISH := A_CUSTOMER_NOT_FOUND.LAST;

      B_IS_EXISTS := N_FINISH > 0 AND N_START > 0;

      IF (B_IS_EXISTS)
      THEN
        BEGIN
          BEGIN
            FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
            UPDATE RTL_B.CUSTOMER_SYNCHRONIZE
            SET SYNCHRONIZE_STATUS = STATUS_NOT_FOUND
            WHERE
              RTL_B.CUSTOMER_SYNCHRONIZE.ROWID = A_CUSTOMER_NOT_FOUND(indx).SYNCHRONIZE_ROWID;
            EXCEPTION
            WHEN OTHERS THEN

            N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
            FOR i IN 1 .. N_ERROR_COUNT
            LOOP
              S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
              S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

              S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

              ADD_LOG(N_RUN, S_ERROR);

            END LOOP;
          END;

          BEGIN

            FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
            DELETE FROM RTL_B.TRANSMITING_CUSTOMER
            WHERE
              SYNCHRONIZE_ROWID IN
              (
                SELECT T.SYNCHRONIZE_ROWID
                FROM
                  RTL_B.TRANSMITING_CUSTOMER T
                  JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
                    ON T.SYNCHRONIZE_ROWID = S.ROWID
                WHERE
                  S.ROWID = A_CUSTOMER_NOT_FOUND(indx).SYNCHRONIZE_ROWID
              );
            EXCEPTION
            WHEN OTHERS THEN

            N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
            FOR i IN 1 .. N_ERROR_COUNT
            LOOP
              S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
              S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

              S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

              ADD_LOG(N_RUN, S_ERROR);

            END LOOP;

          END;

        END;
      END IF;
    END;

  PROCEDURE EXCLUDE_NOT_REQUIRE(N_RUN IN NUMBER) IS

    CURSOR GET_NOT_REQUIRE IS
      SELECT S.ROWID AS SYNCHRONIZE_ROWID
      FROM
        RTL_B.TRANSMITING_CUSTOMER T
        JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
          ON T.SYNCHRONIZE_ROWID = S.ROWID
        JOIN RTL_A.CUSTOMER NR
          ON S.CUSTOMER_CODE = NR.CODE
      WHERE
        S.SYNCHRONIZE_STATUS = STATUS_INITIALIZE
    ;

    TYPE T_CUSTOMER_NOT_REQUIRE IS TABLE OF GET_NOT_REQUIRE%ROWTYPE INDEX BY PLS_INTEGER;
    A_CUSTOMER_NOT_REQUIRE T_CUSTOMER_NOT_REQUIRE;

    N_START                NUMBER := 0;
    N_FINISH               NUMBER := 0;

    S_ERROR                VARCHAR2(4000) := '';
    S_SQLCODE              VARCHAR2(4000) := '';
    S_SQLERRM              VARCHAR2(4000) := '';
    N_ERROR_COUNT          NUMBER := 0;

    B_IS_EXISTS            BOOLEAN := FALSE;

    BEGIN
      OPEN GET_NOT_REQUIRE;
      FETCH GET_NOT_REQUIRE BULK COLLECT INTO A_CUSTOMER_NOT_REQUIRE;
      CLOSE GET_NOT_REQUIRE;

      N_START := A_CUSTOMER_NOT_REQUIRE.FIRST;
      N_FINISH := A_CUSTOMER_NOT_REQUIRE.LAST;

      B_IS_EXISTS := N_FINISH > 0 AND N_START > 0;

      IF (B_IS_EXISTS)
      THEN
        BEGIN

          BEGIN
            FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
            UPDATE RTL_B.CUSTOMER_SYNCHRONIZE
            SET SYNCHRONIZE_STATUS = STATUS_NOT_REQUIRE
            WHERE
              RTL_B.CUSTOMER_SYNCHRONIZE.ROWID = A_CUSTOMER_NOT_REQUIRE(indx).SYNCHRONIZE_ROWID;
            EXCEPTION
            WHEN OTHERS THEN

            N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
            FOR i IN 1 .. N_ERROR_COUNT
            LOOP
              S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
              S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

              S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

              ADD_LOG(N_RUN, S_ERROR);

            END LOOP;
          END;

          BEGIN

            FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
            DELETE FROM RTL_B.TRANSMITING_CUSTOMER
            WHERE
              SYNCHRONIZE_ROWID IN
              (
                SELECT T.SYNCHRONIZE_ROWID
                FROM
                  RTL_B.TRANSMITING_CUSTOMER T
                  JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
                    ON T.SYNCHRONIZE_ROWID = S.ROWID
                WHERE
                  S.ROWID = A_CUSTOMER_NOT_REQUIRE(indx).SYNCHRONIZE_ROWID
              );

            EXCEPTION
            WHEN OTHERS THEN

            N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
            FOR i IN 1 .. N_ERROR_COUNT
            LOOP
              S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
              S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

              S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

              ADD_LOG(N_RUN, S_ERROR);

            END LOOP;
          END;
        END;


      END IF;
    END;

  PROCEDURE SET_PREPARE_FOR_TRANSMIT(N_RUN IN NUMBER) IS

    CURSOR GET_PREPARE_FOR_TRANSMIT IS
      SELECT S.ROWID AS SYNCHRONIZE_ROWID
      FROM
        RTL_B.TRANSMITING_CUSTOMER T
        JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
          ON T.SYNCHRONIZE_ROWID = S.ROWID
        JOIN RTL_B.CUSTOMER C
          ON S.CUSTOMER_CODE = C.CODE
      WHERE
        S.SYNCHRONIZE_STATUS = STATUS_INITIALIZE;

    TYPE T_PREPARE_FOR_TRANSMIT IS TABLE OF GET_PREPARE_FOR_TRANSMIT%ROWTYPE INDEX BY PLS_INTEGER;
    A_PREPARE_CUSTOMER_TRANSMIT T_PREPARE_FOR_TRANSMIT;

    N_START                     NUMBER := 0;
    N_FINISH                    NUMBER := 0;

    S_ERROR                     VARCHAR2(4000) := '';
    S_SQLCODE                   VARCHAR2(4000) := '';
    S_SQLERRM                   VARCHAR2(4000) := '';
    N_ERROR_COUNT               NUMBER := 0;

    B_IS_EXISTS                 BOOLEAN := FALSE;

    BEGIN
      OPEN GET_PREPARE_FOR_TRANSMIT;
      FETCH GET_PREPARE_FOR_TRANSMIT BULK COLLECT INTO A_PREPARE_CUSTOMER_TRANSMIT;
      CLOSE GET_PREPARE_FOR_TRANSMIT;

      N_START := A_PREPARE_CUSTOMER_TRANSMIT.FIRST;
      N_FINISH := A_PREPARE_CUSTOMER_TRANSMIT.LAST;

      B_IS_EXISTS := N_FINISH > 0 AND N_START > 0;

      IF (B_IS_EXISTS)
      THEN
        BEGIN
          FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
          UPDATE RTL_B.CUSTOMER_SYNCHRONIZE
          SET SYNCHRONIZE_STATUS = STATUS_PREPARE
          WHERE
            RTL_B.CUSTOMER_SYNCHRONIZE.ROWID = A_PREPARE_CUSTOMER_TRANSMIT(indx).SYNCHRONIZE_ROWID;

          EXCEPTION
          WHEN OTHERS THEN

          N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
          FOR i IN 1 .. N_ERROR_COUNT
          LOOP
            S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
            S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

            S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

            ADD_LOG(N_RUN, S_ERROR);

          END LOOP;
        END;
      END IF;
    END;

  PROCEDURE INITIALIZE_CUSTOMER_ADDRESS(N_RUN IN NUMBER) IS

    CURSOR GET_CUSTOMER_ADDRESS IS
      SELECT
        S.ROWID   AS SYNCHRONIZE_ROWID,
        A.ADDRESS AS CUSTOMER_ADDRESS
      FROM
        RTL_B.TRANSMITING_CUSTOMER T
        JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
          ON T.SYNCHRONIZE_ROWID = S.ROWID
        JOIN RTL_B.CUSTOMER C
          ON S.CUSTOMER_CODE = C.CODE
        JOIN RTL_B.CUSTOMER_ADDRESS A
          ON A.CUSTOMER_ID = C.ID
      WHERE
        S.SYNCHRONIZE_STATUS = STATUS_PREPARE;

    TYPE T_CUSTOMER_ADDRESS IS TABLE OF GET_CUSTOMER_ADDRESS%ROWTYPE INDEX BY PLS_INTEGER;
    A_CUSTOMER_ADDRESS T_CUSTOMER_ADDRESS;

    N_START            NUMBER := 0;
    N_FINISH           NUMBER := 0;

    S_ERROR            VARCHAR2(4000) := '';
    S_SQLCODE          VARCHAR2(4000) := '';
    S_SQLERRM          VARCHAR2(4000) := '';
    N_ERROR_COUNT      NUMBER := 0;

    B_IS_EXISTS        BOOLEAN := FALSE;

    BEGIN
      OPEN GET_CUSTOMER_ADDRESS;
      FETCH GET_CUSTOMER_ADDRESS BULK COLLECT INTO A_CUSTOMER_ADDRESS;
      CLOSE GET_CUSTOMER_ADDRESS;

      N_START := A_CUSTOMER_ADDRESS.FIRST;
      N_FINISH := A_CUSTOMER_ADDRESS.LAST;

      B_IS_EXISTS := N_FINISH > 0 AND N_START > 0;

      IF (B_IS_EXISTS)
      THEN
        BEGIN
          FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
          INSERT INTO RTL_B.TRANSMITING_ADDRESS
          (ADDRESS, SYNCHRONIZE_ROWID)
          VALUES (A_CUSTOMER_ADDRESS(indx).CUSTOMER_ADDRESS, A_CUSTOMER_ADDRESS(indx).SYNCHRONIZE_ROWID);

          EXCEPTION
          WHEN OTHERS THEN

          N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
          FOR i IN 1 .. N_ERROR_COUNT
          LOOP
            S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
            S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

            S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

            ADD_LOG(N_RUN, S_ERROR);

          END LOOP;
        END;
      END IF;
    END;

  PROCEDURE INITIALIZE_CUST_CERTIFICATE(N_RUN IN NUMBER) IS

    CURSOR GET_CUSTOMER_CERTIFICATE IS
      SELECT
        S.ROWID        AS SYNCHRONIZE_ROWID,
        CR.CERTIFICATE AS CUSTOMER_CERTIFICATE
      FROM
        RTL_B.TRANSMITING_CUSTOMER T
        JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
          ON T.SYNCHRONIZE_ROWID = S.ROWID
        JOIN RTL_B.CUSTOMER C
          ON S.CUSTOMER_CODE = C.CODE
        JOIN RTL_B.CUSTOMER_CERTIFICATE CR
          ON CR.CUSTOMER_ID = C.ID
      WHERE
        S.SYNCHRONIZE_STATUS = STATUS_PREPARE;

    TYPE T_CUSTOMER_CERTIFICATE IS TABLE OF GET_CUSTOMER_CERTIFICATE%ROWTYPE INDEX BY PLS_INTEGER;
    A_CUSTOMER_CERTIFICATE T_CUSTOMER_CERTIFICATE;

    N_START                NUMBER := 0;
    N_FINISH               NUMBER := 0;

    S_ERROR                VARCHAR2(4000) := '';
    S_SQLCODE              VARCHAR2(4000) := '';
    S_SQLERRM              VARCHAR2(4000) := '';
    N_ERROR_COUNT          NUMBER := 0;

    B_IS_EXISTS            BOOLEAN := FALSE;

    BEGIN
      OPEN GET_CUSTOMER_CERTIFICATE;
      FETCH GET_CUSTOMER_CERTIFICATE BULK COLLECT INTO A_CUSTOMER_CERTIFICATE;
      CLOSE GET_CUSTOMER_CERTIFICATE;

      N_START := A_CUSTOMER_CERTIFICATE.FIRST;
      N_FINISH := A_CUSTOMER_CERTIFICATE.LAST;

      B_IS_EXISTS := N_FINISH > 0 AND N_START > 0;

      IF (B_IS_EXISTS)
      THEN
        BEGIN
          FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
          INSERT INTO RTL_B.TRANSMITING_CERTIFICATE
          (CERTIFICATE, SYNCHRONIZE_ROWID)
          VALUES (A_CUSTOMER_CERTIFICATE(indx).CUSTOMER_CERTIFICATE, A_CUSTOMER_CERTIFICATE(indx).SYNCHRONIZE_ROWID);

          EXCEPTION
          WHEN OTHERS THEN

          N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
          FOR i IN 1 .. N_ERROR_COUNT
          LOOP
            S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
            S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

            S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

            ADD_LOG(N_RUN, S_ERROR);

          END LOOP;
        END;
      END IF;
    END;

  PROCEDURE INITIALIZE_CUSTOMER_CONTACT(N_RUN IN NUMBER) IS

    CURSOR GET_CUSTOMER_CONTACT IS
      SELECT
        S.ROWID    AS SYNCHRONIZE_ROWID,
        CN.CONTACT AS CUSTOMER_CONTACT
      FROM
        RTL_B.TRANSMITING_CUSTOMER T
        JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
          ON T.SYNCHRONIZE_ROWID = S.ROWID
        JOIN RTL_B.CUSTOMER C
          ON S.CUSTOMER_CODE = C.CODE
        JOIN RTL_B.CUSTOMER_CONTACT CN
          ON CN.CUSTOMER_ID = C.ID
      WHERE
        S.SYNCHRONIZE_STATUS = STATUS_PREPARE;

    TYPE T_CUSTOMER_CONTACT IS TABLE OF GET_CUSTOMER_CONTACT%ROWTYPE INDEX BY PLS_INTEGER;
    A_CUSTOMER_CONTACT T_CUSTOMER_CONTACT;

    N_START            NUMBER := 0;
    N_FINISH           NUMBER := 0;

    S_ERROR            VARCHAR2(4000) := '';
    S_SQLCODE          VARCHAR2(4000) := '';
    S_SQLERRM          VARCHAR2(4000) := '';
    N_ERROR_COUNT      NUMBER := 0;

    B_IS_EXISTS        BOOLEAN := FALSE;

    BEGIN
      OPEN GET_CUSTOMER_CONTACT;
      FETCH GET_CUSTOMER_CONTACT BULK COLLECT INTO A_CUSTOMER_CONTACT;
      CLOSE GET_CUSTOMER_CONTACT;

      N_START := A_CUSTOMER_CONTACT.FIRST;
      N_FINISH := A_CUSTOMER_CONTACT.LAST;

      B_IS_EXISTS := N_FINISH > 0 AND N_START > 0;

      IF (B_IS_EXISTS)
      THEN
        BEGIN
          FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
          INSERT INTO RTL_B.TRANSMITING_CONTACT
          (CONTACT, SYNCHRONIZE_ROWID)
          VALUES (A_CUSTOMER_CONTACT(indx).CUSTOMER_CONTACT, A_CUSTOMER_CONTACT(indx).SYNCHRONIZE_ROWID);

          EXCEPTION
          WHEN OTHERS THEN

          N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
          FOR i IN 1 .. N_ERROR_COUNT
          LOOP
            S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
            S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

            S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

            ADD_LOG(N_RUN, S_ERROR);

          END LOOP;
        END;
      END IF;
    END;

  PROCEDURE TRANSMIT_CUSTOMER IS

    N_START     NUMBER := 0;

    B_IS_EXISTS BOOLEAN := FALSE;
    BEGIN
      SELECT CASE
             WHEN EXISTS(SELECT NULL
                         FROM RTL_B.TRANSMITING_CUSTOMER)
               THEN 1
             ELSE 0
             END CASE
      INTO N_START
      FROM DUAL;

      B_IS_EXISTS := N_START > 0;
      IF (B_IS_EXISTS)
      THEN
        BEGIN
          INSERT INTO RTL_A.CUSTOMER
          (CODE, TITLE)
            SELECT
              S.CUSTOMER_CODE,
              T.TITLE
            FROM
              RTL_B.CUSTOMER_SYNCHRONIZE S
              JOIN RTL_B.TRANSMITING_CUSTOMER T
                ON S.ROWID = T.SYNCHRONIZE_ROWID
            WHERE
              S.SYNCHRONIZE_STATUS = STATUS_PREPARE
              AND NOT EXISTS(SELECT NULL
                             FROM RTL_A.CUSTOMER A
                             WHERE A.CODE = S.CUSTOMER_CODE);
        END;
      END IF;
    END;

  PROCEDURE TRANSMIT_CUSTOMER_ADDRESS(N_RUN IN NUMBER) IS

    CURSOR GET_CUSTOMER_ADDRESS_KIT IS
      SELECT
        TC.ID      AS TARGET_CUSTOMER,
        SA.ADDRESS AS SOURCE_ADDRESS
      FROM
        RTL_B.TRANSMITING_CUSTOMER T
        JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
          ON T.SYNCHRONIZE_ROWID = S.ROWID
        JOIN RTL_A.CUSTOMER TC
          ON S.CUSTOMER_CODE = TC.CODE
        JOIN RTL_B.TRANSMITING_ADDRESS SA
          ON SA.SYNCHRONIZE_ROWID = T.SYNCHRONIZE_ROWID
      WHERE
        S.SYNCHRONIZE_STATUS = STATUS_PREPARE;

    TYPE T_CUSTOMER_ADDRESS_KIT IS TABLE OF GET_CUSTOMER_ADDRESS_KIT%ROWTYPE INDEX BY PLS_INTEGER;
    A_CUSTOMER_ADDRESS_KIT T_CUSTOMER_ADDRESS_KIT;

    N_START                NUMBER := 0;
    N_FINISH               NUMBER := 0;

    S_ERROR                VARCHAR2(4000) := '';
    S_SQLCODE              VARCHAR2(4000) := '';
    S_SQLERRM              VARCHAR2(4000) := '';
    N_ERROR_COUNT          NUMBER := 0;

    B_IS_EXISTS            BOOLEAN := FALSE;

    BEGIN
      OPEN GET_CUSTOMER_ADDRESS_KIT;
      FETCH GET_CUSTOMER_ADDRESS_KIT BULK COLLECT INTO A_CUSTOMER_ADDRESS_KIT;
      CLOSE GET_CUSTOMER_ADDRESS_KIT;

      N_START := A_CUSTOMER_ADDRESS_KIT.FIRST;
      N_FINISH := A_CUSTOMER_ADDRESS_KIT.LAST;

      B_IS_EXISTS := N_FINISH > 0 AND N_START > 0;

      IF (B_IS_EXISTS)
      THEN
        BEGIN
          FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
          INSERT INTO RTL_A.CUSTOMER_ADDRESS
          (CUSTOMER_ID, ADDRESS)
          VALUES (A_CUSTOMER_ADDRESS_KIT(indx).TARGET_CUSTOMER, A_CUSTOMER_ADDRESS_KIT(indx).SOURCE_ADDRESS);

          EXCEPTION
          WHEN OTHERS THEN

          N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
          FOR i IN 1 .. N_ERROR_COUNT
          LOOP
            S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
            S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

            S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

            ADD_LOG(N_RUN, S_ERROR);

          END LOOP;
        END;
      END IF;
    END;

  PROCEDURE TRANSMIT_CUSTOMER_CONTACT(N_RUN IN NUMBER) IS

    CURSOR GET_CUSTOMER_CONTACT_KIT IS
      SELECT
        TC.ID      AS TARGET_CUSTOMER,
        SC.CONTACT AS SOURCE_CONTACT
      FROM
        RTL_B.TRANSMITING_CUSTOMER T
        JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
          ON T.SYNCHRONIZE_ROWID = S.ROWID
        JOIN RTL_A.CUSTOMER TC
          ON S.CUSTOMER_CODE = TC.CODE
        JOIN RTL_B.TRANSMITING_CONTACT SC
          ON SC.SYNCHRONIZE_ROWID = T.SYNCHRONIZE_ROWID
      WHERE
        S.SYNCHRONIZE_STATUS = STATUS_PREPARE;

    TYPE T_CUSTOMER_CONTACT_KIT IS TABLE OF GET_CUSTOMER_CONTACT_KIT%ROWTYPE INDEX BY PLS_INTEGER;
    A_CUSTOMER_CONTACT_KIT T_CUSTOMER_CONTACT_KIT;

    N_START                NUMBER := 0;
    N_FINISH               NUMBER := 0;

    S_ERROR                VARCHAR2(4000) := '';
    S_SQLCODE              VARCHAR2(4000) := '';
    S_SQLERRM              VARCHAR2(4000) := '';
    N_ERROR_COUNT          NUMBER := 0;

    B_IS_EXISTS            BOOLEAN := FALSE;

    BEGIN
      OPEN GET_CUSTOMER_CONTACT_KIT;
      FETCH GET_CUSTOMER_CONTACT_KIT BULK COLLECT INTO A_CUSTOMER_CONTACT_KIT;
      CLOSE GET_CUSTOMER_CONTACT_KIT;

      N_START := A_CUSTOMER_CONTACT_KIT.FIRST;
      N_FINISH := A_CUSTOMER_CONTACT_KIT.LAST;

      B_IS_EXISTS := N_FINISH > 0 AND N_START > 0;

      IF (B_IS_EXISTS)
      THEN
        BEGIN
          FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
          INSERT INTO RTL_A.CUSTOMER_CONTACT
          (CUSTOMER_ID, CONTACT)
          VALUES (A_CUSTOMER_CONTACT_KIT(indx).TARGET_CUSTOMER, A_CUSTOMER_CONTACT_KIT(indx).SOURCE_CONTACT);

          EXCEPTION
          WHEN OTHERS THEN

          N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
          FOR i IN 1 .. N_ERROR_COUNT
          LOOP
            S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
            S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

            S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

            ADD_LOG(N_RUN, S_ERROR);

          END LOOP;
        END;
      END IF;
    END;

  PROCEDURE TRANSMIT_CUSTOMER_CERTIFICATE(N_RUN IN NUMBER) IS

    CURSOR GET_CUSTOMER_CERTIFICATE_KIT IS
      SELECT
        TC.ID          AS TARGET_CUSTOMER,
        SC.CERTIFICATE AS SOURCE_CERTIFICATE
      FROM
        RTL_B.TRANSMITING_CUSTOMER T
        JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
          ON T.SYNCHRONIZE_ROWID = S.ROWID
        JOIN RTL_A.CUSTOMER TC
          ON S.CUSTOMER_CODE = TC.CODE
        JOIN RTL_B.TRANSMITING_CERTIFICATE SC
          ON SC.SYNCHRONIZE_ROWID = T.SYNCHRONIZE_ROWID
      WHERE
        S.SYNCHRONIZE_STATUS = STATUS_PREPARE;

    TYPE T_CUSTOMER_CERTIFICATE_KIT IS TABLE OF GET_CUSTOMER_CERTIFICATE_KIT%ROWTYPE INDEX BY PLS_INTEGER;
    A_CUSTOMER_CERTIFICATE_KIT T_CUSTOMER_CERTIFICATE_KIT;

    N_START                    NUMBER := 0;
    N_FINISH                   NUMBER := 0;

    S_ERROR                    VARCHAR2(4000) := '';
    S_SQLCODE                  VARCHAR2(4000) := '';
    S_SQLERRM                  VARCHAR2(4000) := '';
    N_ERROR_COUNT              NUMBER := 0;

    B_IS_EXISTS                BOOLEAN := FALSE;

    BEGIN
      OPEN GET_CUSTOMER_CERTIFICATE_KIT;
      FETCH GET_CUSTOMER_CERTIFICATE_KIT BULK COLLECT INTO A_CUSTOMER_CERTIFICATE_KIT;
      CLOSE GET_CUSTOMER_CERTIFICATE_KIT;

      N_START := A_CUSTOMER_CERTIFICATE_KIT.FIRST;
      N_FINISH := A_CUSTOMER_CERTIFICATE_KIT.LAST;

      B_IS_EXISTS := N_FINISH > 0 AND N_START > 0;

      IF (B_IS_EXISTS)
      THEN
        BEGIN
          FORALL indx IN N_START .. N_FINISH SAVE EXCEPTIONS
          INSERT INTO RTL_A.CUSTOMER_CERTIFICATE
          (CUSTOMER_ID, CERTIFICATE)
          VALUES
            (A_CUSTOMER_CERTIFICATE_KIT(indx).TARGET_CUSTOMER, A_CUSTOMER_CERTIFICATE_KIT(indx).SOURCE_CERTIFICATE);

          EXCEPTION
          WHEN OTHERS THEN

          N_ERROR_COUNT := SQL%BULK_EXCEPTIONS.COUNT;
          FOR i IN 1 .. N_ERROR_COUNT
          LOOP
            S_SQLCODE := SQL%BULK_EXCEPTIONS(i).ERROR_CODE;
            S_SQLERRM := SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE);

            S_ERROR := ' SQLCODE => ' || S_SQLCODE || '; SQLERRM => ' || S_SQLERRM;

            ADD_LOG(N_RUN, S_ERROR);

          END LOOP;

        END;
      END IF;
    END;

  BEGIN

    SELECT SOME.TRANSMITING_RUN_SEQ.NEXTVAL
    INTO N_RUN_NUMBER
    FROM DUAL;

    ADD_LOG(N_RUN_NUMBER, 'START');

    INITIALIZE;
    INITIALIZE_SYNCHRONIZE(N_RUN_NUMBER);

    /* EXCLUDE UN_INITIALIZED RECORDS */
    DELETE FROM RTL_B.TRANSMITING_CUSTOMER
    WHERE
      SYNCHRONIZE_ROWID IN
      (
        SELECT T.SYNCHRONIZE_ROWID
        FROM
          RTL_B.TRANSMITING_CUSTOMER T
          JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
            ON T.SYNCHRONIZE_ROWID = S.ROWID
        WHERE
          S.SYNCHRONIZE_STATUS <> STATUS_INITIALIZE
      );

    EXCLUDE_NOT_FOUND(N_RUN_NUMBER);
    EXCLUDE_NOT_REQUIRE(N_RUN_NUMBER);

    /* INITIALIZE_CUSTOMER */
    UPDATE RTL_B.TRANSMITING_CUSTOMER U
    SET TITLE = (
      SELECT C.TITLE
      FROM
        RTL_B.TRANSMITING_CUSTOMER T
        JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
          ON T.SYNCHRONIZE_ROWID = S.ROWID
        JOIN RTL_B.CUSTOMER C
          ON S.CUSTOMER_CODE = C.CODE
      WHERE
        U.SYNCHRONIZE_ROWID = T.SYNCHRONIZE_ROWID
    )
    WHERE
      EXISTS(
          SELECT NULL
          FROM
            RTL_B.TRANSMITING_CUSTOMER T
            JOIN RTL_B.CUSTOMER_SYNCHRONIZE S
              ON T.SYNCHRONIZE_ROWID = S.ROWID
          WHERE
            U.SYNCHRONIZE_ROWID = T.SYNCHRONIZE_ROWID
      );

    SET_PREPARE_FOR_TRANSMIT(N_RUN_NUMBER);

    INITIALIZE_CUSTOMER_ADDRESS(N_RUN_NUMBER);
    INITIALIZE_CUST_CERTIFICATE(N_RUN_NUMBER);
    INITIALIZE_CUSTOMER_CONTACT(N_RUN_NUMBER);

    TRANSMIT_CUSTOMER;
    TRANSMIT_CUSTOMER_ADDRESS(N_RUN_NUMBER);

    DELETE FROM RTL_B.TRANSMITING_ADDRESS;

    TRANSMIT_CUSTOMER_CERTIFICATE(N_RUN_NUMBER);

    DELETE FROM RTL_B.TRANSMITING_CERTIFICATE;

    TRANSMIT_CUSTOMER_CONTACT(N_RUN_NUMBER);

    DELETE FROM RTL_B.TRANSMITING_CONTACT;

    /* SET_SUCCESS*/
    UPDATE RTL_B.CUSTOMER_SYNCHRONIZE
    SET SYNCHRONIZE_STATUS = STATUS_SUCCESS
    WHERE
      ROWID IN (
        SELECT T.SYNCHRONIZE_ROWID
        FROM
          RTL_B.TRANSMITING_CUSTOMER T
      );

    /* CLEANUP */
    DELETE FROM RTL_B.TRANSMITING_CUSTOMER;

    /* END processing RTL_B */


    C_RESULT := 'OK';

    ADD_LOG(N_RUN_NUMBER, 'FINISH', C_RESULT);

    EXCEPTION
    WHEN OTHERS THEN

    S_CALL_STACK := DBMS_UTILITY.FORMAT_CALL_STACK;
    S_ERROR_BACKTRACE := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    S_ERROR_STACK := DBMS_UTILITY.FORMAT_ERROR_STACK;

    S_ADDITIONAL_INFORMATION := 'CALL_STACK => '
                                || S_CALL_STACK
                                || '; ERROR_BACKTRACE => '
                                || S_ERROR_BACKTRACE
                                || '; ERROR_STACK => '
                                || S_ERROR_STACK;

    S_E_SQLCODE := SQLCODE;
    S_E_SQLERRM := SQLERRM;

    S_ERROR_MESSAGE := ' SQLCODE => ' || S_E_SQLCODE || '; SQLERRM => ' || S_E_SQLERRM;

    ADD_LOG(N_RUN_NUMBER, S_ERROR_MESSAGE, S_ADDITIONAL_INFORMATION);
  END;
